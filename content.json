{"meta":{"title":"飞天","subtitle":null,"description":null,"author":"fly-wind","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"前端综合问题","slug":"other-comprehensive","date":"2018-07-21T15:43:00.000Z","updated":"2018-07-21T16:50:15.846Z","comments":true,"path":"2018/07/21/other-comprehensive/","link":"","permalink":"http://yoursite.com/2018/07/21/other-comprehensive/","excerpt":"本文涉及的方面比较广泛，html、css、网络都有，大多数都为常见问题。","text":"本文涉及的方面比较广泛，html、css、网络都有，大多数都为常见问题。 访问一个url都有哪些过程 DNS 查询 TCP 握手、TLS 握手 HTTP请求 服务器处理请求 浏览器渲染 解析 DOM 结构，生成 DOM 树 生成 render 树 （DOM + CSSOM） 布局 render 树 展示 render 树 Url的组成部分 协议 + 域名 + 资源路径 + 参数 Tcp网络 组成部分：网络接口层、网络层、传输层、应用层 三次握手 第一次握手：客户端发送 syn 包(syn=j)到服务器。 第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=j+1），同时自己也发送一个 ASK 包（ask=k）。 第三次握手：客户端收到服务器的 SYN＋ACK 包，向服务器发送确认包 ACK(ack=k+1)。 安全性能 CSRF(Cross-site request forgery) 跨站请求伪造 原理：网站 B 通过让已登录的网站 A 访问带有攻击的链接，从而模拟网站 A 发送请求 防御方式：Token 验证、Referer 验证（服务器只接收本站的请求） XSS(Cross Site Scripting) 跨域脚本攻击 原理：无需登录，通过合法的输入，往网站里注入脚本 防御方式：HTML Entity 编码；过滤输入的信息（和事件相关的属性，如onclick类，script节点，iframe节点） h5都有哪些新特性 语义化标签 header、footer、section等 canvas localStorage 和 sessionStorage 本地缓存的各种方式以及区别 session 通常用于服务端存储 cookie 有有效期，不设置有效期默认关闭页面清空数据 localStorage 永久保存，除非清除浏览器的缓存 sessionStorage 临时保存当前会话的数据，关闭窗口后清空数据 ajax的实现机制 XMLHTTPRequest(XHR) 新建一个 XHR 对象 使用 open 设置请求的参数。open(method, url, 是否异步) 发送请求 注册 onreadystatechange 事件 获取返回的数据 跨域 JSONP 通过 script 标签的异步加载实现。 WebSocket CORS 跨域时，浏览器会拦截 Ajax 的请求，并在 http 头中加 Origin。 Hash 地址栏的 url 后的 # 就是 hash，hash改变页面不会刷新 postMessage 5个海盗平分一百个金币，第一个人做策略，如果有一半人以上投票否决，那个人就会被丢进海里，那么他应该做出什么样的策略 思路： 至少要有 3 个人投决定票，那就是要拉 2 票。 常用的打包工具 webpack parcel 垂直居中怎么实现的 fixed 12345position: fixed;width: 100px;height: 40px;left: 0;right: 0; absolute，父元素宽高要固定 12345678910111213&#123; position: absolute; top: 50%; transform: translateY(-50%);&#125;&#123; position: absolute; margin: auto; top: 0; bottom: 0; width: 50px; height: 50px;&#125; flex 1234display: flex;height: 100%;justify-content: center;align-items: center; position四个定位的区别 relative 相对定位。相对于其他正常的元素去定位 absolute 绝对定位。相对于 static 定位以外的第一个父元素进行定位。 fixed 固定定位。相对于浏览器窗口定位。 static 没有定位。默认值 inline和inline-block的区别 inline 宽度与自身内容同宽；不会占据一行；不能设置宽高值；margin、padding水平方向的设置有效，垂直方向的无效 inline-block 具备 inline 的同行特性 和 block 的宽高特性，不占据一行，可以设置宽高值、margin、padding 三列布局，左右两块固定宽度，中间宽度占据剩余的空间，都有哪些实现方式 flex 左右两边flex: 0 0 100px;，中间flex: 1 float 左右两边浮动，设置固定宽度，中间margin-left: 100px; margin-right: 100px; absolute 跟 float 一样的逻辑，用 left 和 right 来控制 样式的优先级!important &gt; 内联 &gt; id &gt; class = 属性 = 伪类(:hover) &gt; 标签 = 伪元素(::before) ws如何知道接收到的信息来自于哪个发送请求浏览器兼容性能优化","categories":[],"tags":[{"name":"other","slug":"other","permalink":"http://yoursite.com/tags/other/"}]},{"title":"js - 综合常见问题","slug":"js-question","date":"2018-07-21T03:10:04.000Z","updated":"2018-07-30T14:26:49.009Z","comments":true,"path":"2018/07/21/js-question/","link":"","permalink":"http://yoursite.com/2018/07/21/js-question/","excerpt":"js 的一些基础知识，如对 dom 的操作，继承对象等。","text":"js 的一些基础知识，如对 dom 的操作，继承对象等。 1、Js是怎么实现方法的继承的 原型继承 call() 继承 2、涉及到数组的函数都有哪些 concat() 连接两个或更多的数组，并返回结果。join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。pop() 删除并返回数组的最后一个元素push() 向数组的末尾添加一个或更多元素，并返回新的长度。reverse() 颠倒数组中元素的顺序。shift() 删除并返回数组的第一个元素slice() 从某个已有的数组返回选定的元素sort() 对数组的元素进行排序splice() 删除元素，并向数组添加新元素。toSource() 返回该对象的源代码。toString() 把数组转换为字符串，并返回结果。toLocaleString() 把数组转换为本地数组，并返回结果。unshift() 向数组的开头添加一个或更多元素，并返回新的长度。valueOf() 返回数组对象的原始值 3、复制一个数组的函数针对性能而言：对于 webkit, 使用 concat(); 其他浏览器, 使用 slice(). slice() let arr = oldArray.slice();concat() let arr = oldArray.concat();from() let arr = Array.from(oldArray);push() let arr = []; Array.prototype.push.apply(arr, oldArray);loop array 4、用什么方式获取元素 ID（getElementById）name属性（getElementsByName）标签名（getElementsByTagName）类名（getElementsByClassName）获取html（document.documentElement）获取body（document.body）通过选择器获取一个元素（querySelector）通过选择器获取一组元素（querySelectorAll） 5、apply call bind 有什么区别假如有以下两个对象，为了要 man 对象也能用到 guy 对象的值，而使用这三种方式。123456789var man = &#123; name: &apos;毛头&apos;, hit: function(sth, who)&#123; console.log(this.name + &apos;用&apos; + sth + &apos;打&apos; + who); &#125;&#125;;var guy = &#123; name: &apos;灭霸&apos;&#125;; 共同点 都用来改变函数的 this 对象的指向。 第一个参数都是 this 要指向的对象。 都可以利用后续参数传参。 不同点 man.hit.call(guy, &#39;响指&#39;, &#39;你&#39;); 后面参数个数与 hit 方法的参数个数一致。 man.hit.apply(guy, [&#39;响指&#39;, &#39;你&#39;]); 后面参数为一个数组，数组里的元素个数与 hit 方法的参数个数一致。 man.hit.bind(guy)(&#39;响指&#39;, &#39;你&#39;); 或者 man.hit.bind(guy, &#39;面条&#39;, &#39;你&#39;)(); 因为bind()返回的是一个函数，所以还要再用()调用一次 6、var fn = function(){} 和 function fn(){} 有什么区别 前者是定义了一个函数，只有在调用的时候才会初始化，而且在定义后调用该函数才是正常的，否则会出错。 后者定义完成的同时也初始化了函数，在同一作用域内任一位置调用该函数都是可用的。 通常建议使用第一种定义方式，提高代码可读性：先定义后使用。 7、写一个函数，把一个数组随机排序12345678910111213function randomSort(arr, newArr) &#123; // 如果原数组 arr 只有一个值，只要取第一个值返回即可 if(arr.length === 1) &#123; newArr.push(arr[0]); return newArr; &#125; // 随机生成一个下标，下标值在 arr 长度范围内，并把该随机下标对应 arr 数组的值复制到 newArr 中 var random = Math.ceil(Math.random() * arr.length) - 1; newArr.push(arr[random]); // 删除原数组 arr 的对应数组项 arr.splice(random, 1); return randomSort(arr, newArr);&#125; 8、怎么取整数，都有哪些参数 parseInt(string, radix) 第一个参数是字符串，第二个参数是代表进制数（可选） 9、0.1+0.2 等于多少 0.30000000000000004 因为小数以二进制形式表示时是有有穷性的 10、箭头函数有什么好处 代码更加简洁 不会绑定 this 11、什么是冒泡事件 由内到外进行事件传播，直到根节点，e.stopPropagation(); 停止冒泡 捕获，在事件捕获阶段就会触发，从根节点开始从外到内传播 12、排序都有哪些 冒泡排序、快速排序、选择排序、希尔排序、堆排序、插入排序、归并排序、计数排序、桶排序、基数排序 13、如何获取 url 地址栏的每个信息 location.host(hostname、href、pathname、protocol、search) 14、原型链是什么 假如有一个对象是 people，创建了该对象的一个实例 man，那么 man 的原型（_proto_）是 people.prototype，而 people.prototype 的原型是 Object。 每个对象都包含实例成员和原型成员。判断该实例中是否有 name 这个成员，使用 hasOwnProperty(‘name’) ，只追溯到实例；使用 ‘name’ in man ，追溯到实例或原型 15、对某个属性名无序的对象进行有序读取 实现思路：先用 Object.keys(obj) 获取对象的所有属性名，然后对属性名进行排序存放到某个数组中，最后对此数组遍历数组元素对应的 obj 的属性值 16、字符串转json怎么转 eval() JSON.parse() 17、let跟var的区别 let 作用于块级作用域 var 作用于函数作用域 18、面向对象、闭包、模块化、组件化的概念 面向对象： 封装、继承、多态 闭包： 能够读取其他函数内部的变量的函数 模块化： 解耦。把内容分为几个大模块 组件化： 复用小功能 19、如何封装一个组件。比如如果要做一个下拉框的组件，有单选，多选，搜索功能，怎样写可拓展性高，可复用性高20、es6的新特性(常用) let、const 的使用 箭头函数 () =&gt; {} 解构 var [x,y] = [1, 2]; // x = 1; y = 2 字符串内用变量 \\${n}\\ 函数参数默认值 function test(name=&#39;灭霸&#39;){} 模块 export","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"js - 性能优化","slug":"js-performance","date":"2018-07-20T14:49:04.000Z","updated":"2018-07-30T14:28:34.332Z","comments":true,"path":"2018/07/20/js-performance/","link":"","permalink":"http://yoursite.com/2018/07/20/js-performance/","excerpt":"始终坚持只要能在构建时完成的，不要留在运行时做。文章内容主要是针对 js 部分的性能优化，分别从加载、数据存取、DOM渲染、算法、AJAX方面来介绍常见的优化方式。概括性来说就是加快响应速度，为此应尽可能地减少请求，精简内容。另外合理利用性能分析工具，针对性地找出能进行优化的部分。","text":"始终坚持只要能在构建时完成的，不要留在运行时做。文章内容主要是针对 js 部分的性能优化，分别从加载、数据存取、DOM渲染、算法、AJAX方面来介绍常见的优化方式。概括性来说就是加快响应速度，为此应尽可能地减少请求，精简内容。另外合理利用性能分析工具，针对性地找出能进行优化的部分。 加载 script 脚本文件放在 body 底部。 脚本在解析时是逐个文件先下载后解析，放在头部会导致解析页面堵塞。 尽量少使用 script 标签。 可以减少 HTTP 请求数，比如多个脚本文件可以合并为同一个文件。 把文件合并到链接，请求一个链接时再分别下载对应的文件。 压缩文件。Accept-Encoding 支持的格式有：gzip, compress, deflate, identify GZip 压缩（只能压缩文本文件）。 smasher（使用PHP写成的一个小工具） 压缩 js 文件。 JSMin YUI Compressor 实现方式：局部变量变短，对象的属性名引号去掉，中括号换为点，替换其转义字符，合并常量值。 Closure Compiler 调试难 Packer 运行期消耗长 添加 defer 属性。仅对 IE 和 Firefox 有效。 1&lt;script type=&quot;text/javascript&quot; src=&quot;default.js&quot; defer&gt;&lt;/script&gt; 动态加载脚本。在需要的地方添加脚本链接。 1234var script = document.createElement(&apos;script&apos;);script.type = &quot;text/javascript&quot;;script.src = &quot;default.js&quot;;document.getElementByTagName(&apos;head&apos;)[0].appendChild(script) 通过 XHR 对象下载文件。 引用 LazyLoad(1.5kb) 或 LABjs(4.5kb) 延迟加载插件。 12345678910// [] 里可以放多个文件LazyLoad.js([&apos;default.js&apos;], function()&#123; // doing something&#125;);// script() 下载对应的脚本文件；wait() 执行脚本文件后调用的函数；// 如要多个脚本文件，写多个 script 即可，但多个时注意 script 和 wait 的执行顺序$LAB.script(&apos;default&apos;) .wait(function()&#123; // doing something&#125;) HTML5 离线引用缓存manifest 文件加上时间戳确保应用升级时资源最新 CDN（内容分发网络） 避免双重求值 eval(‘arr[0]’) 比 arr[0] 慢 setTimeout() 、 setInterval() 第一个参数传递函数非字符串 避免重复工作 延迟加载（如判断浏览器，无需每次都判断，首次判断结果覆盖当前） 条件预加载（先判断后赋值到当前，适用于马上需要被加载的） 数据存储数据分为：直接量（字符串、数字、布尔值、数组、对象、函数、正则表达式、null、undefined），变量，对象成员（以字符串为索引），数组元素（以数字为索引） 直接量与变量 比 对象成员与数组元素 要快，其中，局部变量 比 全局变量要快。因此定义一个对象、数组时直接赋值可以加快解析速度。 点表示法与括号表示法：在 Safari 中点表示法更快，其他浏览器无太大差别。 with 和 try-catch：改变运行期上下文作用域链，从而改变不同变量的访问速度。 DOM 渲染 减少访问 DOM 的次数 innerHTML 与 原生 DOM(createElement) webkit 内核浏览器中原生DOM快 IE6 中，innerHTML快 访问集合元素（针对循环体里集合遍历次数多） 在循环体外存储集合长度 在循环体外拷贝集合元素为数组 把集合元素事先定义为局部变量 重排（reflow）和重绘（repaint） 产生原因有以下可能性： 添加或者删除 DOM改变元素位置、大小、内容改变浏览器窗口大小渲染器初始化 尽可能减少重排或重绘次数 改变元素时，尽可能所有改变一次性处理，因为如果在改变的过程中再执行查询就会更新当前的所有数据，导致重排或重绘；或者为这些改变合并为一个类，通过控制类名达到改变效果。 隐藏元素-&gt;修改元素-&gt;重现元素 123el.style.display(&apos;none&apos;);update();el.style.display(&apos;block&apos;); 创建文档片段(createDocumentFragment) 123var fragment = document.createDocumentFragment();update();el.appendChild(fragment); 复制当前节点-&gt;修改元素-&gt;新节点替换旧节点 1234// cloneNode 参数：true 复制自身以及递归复制当前节点的所有子孙节点；false 只复制当前节点var clone = el.cloneNode(true);update();old.parentNode.replaceChild(clone, old); offset、scroll、computed 减少对这三个相关的获取次数 对于动画布局为脱离文档流。 事件委托（*） 算法 减少迭代工作量（倒序循环） 减少迭代次数（达夫设备：每次迭代最多赋值 8 个值，使用while 或 switch 来实现） 1234// 执行 n 次，每次调用 8 次函数var n = Math.floor(arr.length/8);// 执行 1 次 调用 m 次函数var m = arr.length%8; if-else 最有可能成立的条件放在首位 减少判断次数，条件间可以嵌套 if(…){ if(…){} } 运行速度：查找表 &gt; switch &gt; if-else 合并排序 迭代取代递归 Memoization，适用于递归场景，把计算中的结果保存下来，比如计算 6!, 在函数计算体里，保存 5!、4!、3!…的计算结果。 位操作 与&amp; 都为 1 的时候为 true 或| 只要有 1 个 1 都为 true 异或^ 只有 1 个 1 时为 true 取反~ 遇 0 即为 true 左移&lt;&lt; 右移&gt;&gt; 使用原生方法 Math.PI Math.abs()等 正则表达式正则匹配步骤：1、创建一个正则对象2、找到匹配起始位置3、匹配每个字元，如果失败了，回到起始位置重新尝试其他的可能性4、匹配一轮失败，回到起始位置，从下一个字符开始作为起始位置继续匹配，直到所有的字符都匹配一次，或者匹配到正确的，才会结束。 IE8 以前，+= 比 = … + … 快 IE7 以前，数组项合并(join)更快 响应接口和 AJAX JS 文件执行不应超过 100ms 定时器延时建议最小值为 25ms start = +new Date() 加号 + 可以将 Date 对象转换为数字 Web Workers 请求数据方式： XMLHTTPRequest(XHR) Dynamic script tag insertion 动态脚本标签插入。不能通过请求发送信息头，参数只能通过 GET。 iframes(少用) Comet(少用) Multipart XHR(MXHR) 使用流功能：当 readyState 为 3 时进行操作，可以减少请求数，但不能缓存接收到的响应。 Beacons 信标。适用于不需要或者需少量回馈时，发送大量数据到服务器 数据格式 JSON 轻量级、解析快。解析 json 方式：eval(‘(‘ + text + ‘)’)，SON.parse(text) JSONP 当涉及敏感数据时，应避用JSONP。 字符分隔自定义格式 十分轻量、解析大数据非常快，但服务端要构造，客户端也要解析这种构造。 XML 广泛应用、支持良好。笨重、解析缓慢。 其他工具 Apache Ant：基于 Java 的一个自动构建软件的工具 Rake：基于 Ruby make：基于 Shell，针对 unix 固定系统 预处理 js 文件（cpp） YUI Profiler：性能分析工具 各浏览器渲染引擎 - DOM渲染 JS Chrome Webkit-WebCore V8 Safari Webkit-WebCore SquirrelFish Firefox Gecko JagerMonkey","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"性能优化","slug":"性能优化","permalink":"http://yoursite.com/tags/性能优化/"}]},{"title":"vue - 全局提示框","slug":"vue-tips","date":"2018-02-28T06:49:55.000Z","updated":"2018-07-21T05:56:00.778Z","comments":true,"path":"2018/02/28/vue-tips/","link":"","permalink":"http://yoursite.com/2018/02/28/vue-tips/","excerpt":"利用 vux-cli 组件创建一个全局自定义的提示框，有使用过 vux 的人都知道，vux 有一个叫 Popup 的组件，可以满足提示框的显示，如下图。但如果每个页面都要使用，那么每次都要引用，就会导致代码变冗余，此时，我们就应该考虑把该组件独立出来，这样每次使用时，只要使用一条语句调用即可。","text":"利用 vux-cli 组件创建一个全局自定义的提示框，有使用过 vux 的人都知道，vux 有一个叫 Popup 的组件，可以满足提示框的显示，如下图。但如果每个页面都要使用，那么每次都要引用，就会导致代码变冗余，此时，我们就应该考虑把该组件独立出来，这样每次使用时，只要使用一条语句调用即可。 先上代码 组件部分 12345678&lt;popup v-model=&quot;tips.showTips&quot; position=&quot;bottom&quot;&gt; &lt;div :class=&quot;[ &#123;&apos;error&apos;: this.tips.type === &apos;error&apos;&#125;, &#123;&apos;right&apos;: this.tips.type === &apos;right&apos;&#125;, &#123;&apos;position-vertical-demo&apos;: true&#125; ]&quot;&gt;&#123;&#123; tips.content &#125;&#125;&lt;/div&gt;&lt;/popup&gt;&lt;router-view @tips=&quot;message&quot;&gt;&lt;/router-view&gt; js 部分 1234567891011121314151617181920data () &#123; return &#123; tips: &#123; content: &apos;&apos;, type: &apos;&apos;, showTips: false &#125; &#125;&#125;,methods: &#123; message (content, type) &#123; this.tips.content = content this.tips.type = type this.tips.showTips = true let that = this setTimeout(function () &#123; that.tips.showTips = false &#125;, 1500) &#125;&#125; 首先，我们要在 App.vue 里使用 popup 组件，因为是在不同的地方调用同样的组件，那么我们应该考虑清楚，每个调用的组件之间有什么不同，然后通过传递不同的参数显示不同的提示框。 这里举例的提示框包含以下参数：提示内容（content）、提示的类型（right/error）。通过绑定变量值 showTips 控制其可见性。 定义一个方法 message 接收传递的参数，并赋值 最后在 router-view 里指定自定义的事件，@ 后接自定义事件名称。在其他任何一个页面，调用该提示框时只要使用 this.$emit(&#39;tips&#39;, &#39;请求错误&#39;, &#39;error&#39;) 即可。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"nginx 代理 vue 项目服务器接口","slug":"vue-ajax","date":"2018-01-18T14:37:41.000Z","updated":"2018-07-21T07:00:02.781Z","comments":true,"path":"2018/01/18/vue-ajax/","link":"","permalink":"http://yoursite.com/2018/01/18/vue-ajax/","excerpt":"vue 使用 ajax 与后端交互时，需要连接 api，与传统的 ajax 不一样，要想在 vue 项目中使用 ajax 请求，必须要有 vue-resource，安装命令如下：","text":"vue 使用 ajax 与后端交互时，需要连接 api，与传统的 ajax 不一样，要想在 vue 项目中使用 ajax 请求，必须要有 vue-resource，安装命令如下：1npm install vue-resource --save 在 main.js 中加入以下语句12import VueResource from &apos;vue-resource&apos;Vue.use(VueResource) 接下来就使用 vue-resource 封装的方法去请求，以下给的是一个 GET 的请求例子假设你要请求的是非本地的服务器数据，某个请求接口地址为 http://fuwuqi/login/ ，后面 params 接的是参数，请求的方式为如下：123456this.$http.get(&apos;http://fuwuqi/login/&apos;, &#123;params: &#123;username: username&#125;&#125;) .then(response =&gt; &#123; // 这里是成功之后的处理 &#125;, response =&gt; &#123; // 这里是失败之后的处理 &#125;) 但是，大家会发现出错了，根据提示 Access-Control-Allow-Origin ，我们发现这是一个跨域的问题，解决的方案是做代理处理。利用一个本地服务器的环境，此处以 nginx 为例，修改 nginx 的配置代理远程服务器。 http://127.0.0.1:8081/ 是 vue 项目运行的地址，指定 /new/ 之后，就可以通过 localhost:8080/new/ 来访问 vue 的项目（nginx的端口号是8080）。123456789101112location /new/ &#123; proxy_pass http://127.0.0.1:8081/; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_read_timeout 43200000; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_buffering off;&#125; 另外，还需要同样配置不同访问地址来指定服务器的地址。123456789101112location /api/ &#123; proxy_pass http://fuwuqi/; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_read_timeout 43200000; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_buffering off;&#125; 到了这一步，我们就可以通过 /api/ 代替远程服务器的地址，连接接口，修改上面请求的代码如下：123456this.$http.get(&apos;/api/login/&apos;, &#123;params: &#123;username: username&#125;&#125;) .then(response =&gt; &#123; // 这里是成功之后的处理 &#125;, response =&gt; &#123; // 这里是失败之后的处理 &#125;) 到了这一步基本就没什么问题了。如果修改了 nginx 的配置后，通过访问 nginx 的地址（如 localhost:8080/new/）显示空白页，并出现提示 app.js 有误，如下图：实际上是因为在编译项目的时候，路径出现了问题，把 vue 项目中的 config/index.js 修改以下代码，就是把 assetsPublicPath 的 ‘/‘ 去掉，然后 npm run dev 重启 vue 项目就能读到项目的文件了，具体原因，有待研究。12345dev: &#123; // Paths assetsSubDirectory: &apos;static&apos;, assetsPublicPath: &apos;&apos;, proxyTable: &#123;&#125;, 我遇到的另一个问题就是，没有了跨域问题，但是一直返回 400 错误，最后发现是 api 连接路径还不完全正确，就是后面的 ‘/api/login/‘ 我漏了最后面的反斜杠，所以有时候，细节很重要，一点点差异都有可能导致失败。 附上 HTTP 的参考文档https://github.com/pagekit/vue-resource/blob/HEAD/docs/http.md","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"js - 运算符","slug":"js-operator","date":"2018-01-15T04:28:12.000Z","updated":"2018-07-21T10:33:43.110Z","comments":true,"path":"2018/01/15/js-operator/","link":"","permalink":"http://yoursite.com/2018/01/15/js-operator/","excerpt":"在基本操作中，几乎都会遇到运算，从小学的加减乘除到往后的非与或，逻辑逐渐变得复杂，了解各种运算符能更方便更准确地来计算结果。","text":"在基本操作中，几乎都会遇到运算，从小学的加减乘除到往后的非与或，逻辑逐渐变得复杂，了解各种运算符能更方便更准确地来计算结果。 赋值 = 运算符右边可以是任意类型的任意值 a = 1 += / -=total += i 等价于 total = total + i关系关系表达式是为了比较两个值，大于、小于、等于，通常用于 if、while、for这些程序结构中。 区别 == 和 ===== 表示只比较值，不比较类型，类型之间可以相互转换=== 表示值和类型都必须相等 &lt; &gt; &gt;= &lt;= 比较两个值之间的大小关系，可以为任意类型 in 左边是字符串，右边是对象，当右边对象中存在左边的字符串的属性名时，返回 true instanceof 左边是一个对象，右边是一个类，当右边的类中有左边的对象实例时，返回 true算术1 + 1‘abc’ + ‘efg’位 逻辑&amp;&amp; || ！通常跟关系运算符一起用&amp;&amp; 表示并，左右两边的操作结果同时为 true|| 表示或者，左右两边的操作结果只要有一个为 true 即可! 表示非，与操作结果相反 字符串特殊其他 待补充","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"jq - 基本事件","slug":"jq-event","date":"2018-01-11T05:58:39.000Z","updated":"2018-07-21T05:56:13.475Z","comments":true,"path":"2018/01/11/jq-event/","link":"","permalink":"http://yoursite.com/2018/01/11/jq-event/","excerpt":"用户的任一操作都应有对应的事件方法。","text":"用户的任一操作都应有对应的事件方法。 点击事件 1$(&apos;...&apos;).click(); 双击事件 1$(&apos;...&apos;).dbclick(); 失焦事件 1$(&apos;...&apos;).blur(); 聚焦事件 1$(&apos;...&apos;).focus(); 改变事件，通常用于 select 标签 1$(&apos;...&apos;).change(); 如果要监控的元素是动态生成的，那么上述方法可能失效，因为在初始化加载时，找不到绑定事件的元素，此时应该用另一种方式对未来的元素绑定 1234567$(document).on(&apos;click&apos;, &apos;#id&apos;, function() &#123; ...&#125;);// 或者知道未来元素的父元素，基于父元素监听子元素也是可以的$(&apos;#parent&apos;).on(&apos;click&apos;, &apos;#child&apos;, function() &#123; ...&#125;);","categories":[],"tags":[{"name":"jq","slug":"jq","permalink":"http://yoursite.com/tags/jq/"}]},{"title":"jq - 获取元素","slug":"jq-getel","date":"2018-01-11T01:43:02.000Z","updated":"2018-07-21T05:56:15.566Z","comments":true,"path":"2018/01/11/jq-getel/","link":"","permalink":"http://yoursite.com/2018/01/11/jq-getel/","excerpt":"任何元素，即使处于不同的结构，也应能通过各种方式获取相应的元素值，或通过自身，或通过同级。","text":"任何元素，即使处于不同的结构，也应能通过各种方式获取相应的元素值，或通过自身，或通过同级。假设原本的 dom 结构为以下结构：1234567891011121314&lt;div class=&quot;parent&quot; id=&quot;baba&quot;&gt; &lt;div class=&quot;child&quot; id=&quot;xiaoming&quot;&gt; 第一代孩子 &lt;div id=&quot;s_child&quot; data-name=&quot;wawa&quot;&gt;第二代孩子&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;child&quot; id=&quot;xiaowang&quot;&gt; 孩子 &lt;div id=&quot;ss_child&quot;&gt;第二代孩子&lt;/div&gt; &lt;select&gt; &lt;option value=&quot;one&quot;&gt;one&lt;/option&gt; &lt;option value=&quot;two&quot;&gt;two&lt;/option&gt; &lt;/select&gt; &lt;/div&gt;&lt;/div&gt; 获取某个类（.类名） 1$(&apos;.parent&apos;) 获取某个 id （#id名） 12$(&apos;#baba&apos;)$(&apos;#s_child, #ss_child&apos;) // 获取两个元素，用逗号隔开 获取某个属性值元素，如果是自定义标签，格式为：标签[data-自定义名称]），如果是标签自身的属性，格式应为：标签:属性 12$(&apos;div[data-name]&apos;)$(&apos;select&gt;option:selected&apos;).val() // 获取选中的 select 框的值，与$(&apos;select&apos;).val() 等值 获取子元素 123456$(&apos;#baba div&apos;) // 返回 baba 的所有后代，包括一代和二代$(&apos;.parent div&apos;) // 同上$(&apos;#baba&gt;div&apos;) // 返回第一代$(&apos;#baba div&apos;).eq(n) // 返回 baba 的第 n 个后代，从 0 开始，如果为 0 ，返回 xiaoming 的节点$(&apos;#baba div&apos;).first() // 返回 baba 的第一个后代，即 xiaoming$(&apos;#baba div&apos;).last() // 返回 baba 的最后一个后代，即 ss_child 获取父元素 123$(&apos;.s_child&apos;).parent() // 获取到第二个 div$(&apos;.s_child&apos;).parent().parent() // 获取到第一个 div ，即 baba$(&apos;.s_child&apos;).closest(&apos;.parent&apos;) // 往上查找，一查到类名为 parent 的元素就停止，并返回查到的节点 baba 获取兄弟节点 123$(&apos;#xiaoming&apos;).sibling() // 返回所有兄弟节点$(&apos;#xiaoming&apos;).next() // 返回下一个节点，即 xiaowang$(&apos;#xiaowang&apos;).prev() // 返回上一个节点，即 xiaoming","categories":[],"tags":[{"name":"jq","slug":"jq","permalink":"http://yoursite.com/tags/jq/"}]},{"title":"js - 表达式","slug":"js-expression","date":"2018-01-09T02:03:24.000Z","updated":"2018-07-21T10:33:35.983Z","comments":true,"path":"2018/01/09/js-expression/","link":"","permalink":"http://yoursite.com/2018/01/09/js-expression/","excerpt":"解释器根据表达式计算出结果。 原始表达式 常量数值（123），字符串（’abc’），正则表达式（/pattern/）","text":"解释器根据表达式计算出结果。 原始表达式 常量数值（123），字符串（’abc’），正则表达式（/pattern/） 保留字true, false, null, this…等更多保留字 变量i; // 一个 i 变量undefined 不是保留字，是全局变量初始化表达式 对象初始化（花括号包含元素，逗号隔开）每个子表达式都包含一个属性名和一个冒号作为前缀 空对象 {} 两个元素的对象 {a:1, b:2} 嵌套对象 {a:{a:1}, b:{b:2}} 数组初始化（中括号包含值，值用逗号隔开） 空数组 [] 给定起始值 [1,2] 嵌套数组，二维数组 [[11,22],[33,44]] 省略中间值，中间未给定的值结果为 undefined [1,,,,2] 函数表达式函数表达式与函数声明有所不同。函数表达式要先定义才能使用，这样的函数也是匿名函数。1234var say = function() &#123; alert(&apos;hello&apos;);&#125;;say(); 函数声明的函数可以直接调用，在代码执行之前就会读取函数的声明1234say();function say() &#123; alert(&apos;hello&apos;);&#125;; 对象创建表达式 内置构造函数创建对象，括号里可以传入不同的参数（数值，字符串，布尔值） 1var obj = new Object() 字面量创建对象。当参数不稳定时，建议使用字面量来创建对象（原因不详）。 1var obj = &#123;a:1&#125;; 自定义构造函数创建对象如果没有指定的 return 对象，默认 return this，不需要明写，返回的必须是对象，如果不是，返回值将会被忽略，跟默认返回一样 123456var Person = function (name)&#123; this.name = name; // return this;&#125;;var obj = new Person(&apos;zhu&apos;);console.log(obj.name); 自定义构造函数看起来跟普通函数一样，如果在创建对象时，没有使用 new 就直接调用了，虽然没有报错，却也得不到自己要的结果，因为此时构造函数里的 this 指向的是全局的 window 对象，使用 window.xxx 即可查看到相应的值。顺便提一下，数组的创建，可以通过 new Array() 或者字面量来创建，一般采取字面量来创建，方便简洁，并且不容易出错。注意的一点是 Array() 参数为 一个数值 时，代表的是数组的长度，字面量可以直接赋予第一个的值，这也意味着如果 Array() 参数传递的是一个浮点型的值，将会出错。 1234var arr = new Array(2);console.log(arr[0]) // undefinedvar arr = [2];console.log(arr[0]) // 2 属性访问表达式点号表示法只适用于当访问的属性名称是合法的标识符且知道要访问的属性名字时，如果属性名是通过求值得到、或包含空格、或为数值、或为保留字，此时应该使用方括号表示法 点号表示法，点号后面不能接数字 obj.x如果对数字字面量使用该方法，且数字没有小数点没有指数，应在点号之前留个空格，避免后面的方法被认为是小数点的值 123456// 1 .x// 1..x// 1.0.x// (1).x// 1.x 方括号表示法 obj[&#39;x&#39;] 调用表达式f(x)","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"js - 基础程序结构","slug":"js-basicpro","date":"2018-01-08T03:01:47.000Z","updated":"2018-07-21T10:33:27.523Z","comments":true,"path":"2018/01/08/js-basicpro/","link":"","permalink":"http://yoursite.com/2018/01/08/js-basicpro/","excerpt":"与其他语言类似，js的基本程序结构包含 3 种，顺序结构，循环结构，分支结构。 1、顺序结构顺序结构，即从上至下，依次执行。","text":"与其他语言类似，js的基本程序结构包含 3 种，顺序结构，循环结构，分支结构。 1、顺序结构顺序结构，即从上至下，依次执行。eg:交换 a 和 b 的值12345var a = 1, b = 2, c = 3;c = a;a = b;b = c;console.log(b); === 1 如果调换语句的顺序，将得到不同的结果12345var a = 1, b = 2, c = 3;a = b;c = a;b = c;console.log(b); === 2 2、循环结构循环结构包含：判断表达式、循环体、结束语句，以下用前三种方式分别求出10以内的正整数和可以用 break 或者 continue 结束语句 for 语句12345var count = 0;for(var i = 0; i &lt;= 10; i++)&#123; count += i;&#125;console.log(count); === 55 for 表达式可以部分省略，但是在此之前要先声明，如下代码所示。如果全部省略（即：for(;;) { … }），将会无限循环12345var i = 0;for(; i &lt;= 10;)&#123; ... i++;&#125; while 语句 1234567var count = 0;var i = 0;while(i &lt;= 10)&#123; count += i; i++;&#125;console.log(count); === 55 do-while 语句循环体里的语句至少被执行一次 1234567var count = 0;var i = 0;do &#123; count += i; i++;&#125; while(i &lt;= 10)console.log(count); === 55 for-in 语句枚举对象。每个对象都应该有值，如果没有值，ECMAScript 5 版本不再执行该循环体，更早的版本会抛出错误 3、分支结构（选择结构） if条件可以是任意表达式，分支内容可以是一条语句，也可以是一个代码块（必须用花括号括起来）不能用 break 或者 continue 结束语句 单向选择 1if(条件) &#123;分支体&#125; 双向选择 1if(条件) &#123;分支1&#125; else &#123;分支2&#125; 多向选择 123if(条件1) &#123;分支1&#125;else if(条件2) &#123;分支2&#125;else &#123;分支3&#125; switch…case 多向选择switch 语句的比较值用的是全等操作符，也就是说值和类型都要一致（10 与 ‘10’ 不相等）1234567891011121314151617181920212223switch(value) &#123; case value1: do something break; case value2: do something break;&#125;// 共同 value 值合并处理switch(value) &#123; case value1: case value2: do something break;&#125;// 默认处理switch(value) &#123; ... default: do something break;&#125; 三目运算条件 ? 操作1（符合条件） : 操作2（不符合条件）eg: 123var a = 10;a &gt; 0 ? a++ : a = 0console.log(a); === 11 顺序结构可以包含循环结构和分支结构","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-12-29T02:49:47.000Z","updated":"2018-02-28T10:10:47.000Z","comments":true,"path":"2017/12/29/hello-world/","link":"","permalink":"http://yoursite.com/2017/12/29/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server(hexo s) More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy git push to github123hexo cleanhexo generate(hexo g)hexo deploy(hexo d) More info: Deployment","categories":[],"tags":[{"name":"other","slug":"other","permalink":"http://yoursite.com/tags/other/"}]}]}